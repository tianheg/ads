# 练习

## Day 1：数组和链表

> 关于数组和链表的几个必知必会的代码实现

### 数组

- 实现一个支持动态扩容的数组
- 实现一个大小固定的有序数组，支持动态增删改操作
- 实现两个有序数组合并为一个有序数组

### 链表

- 实现单链表、循环链表、双向链表，支持增删操作
- 实现单链表反转
- 实现两个有序的链表合并为一个有序链表
- 实现求链表的中间结点

### 对应的 LeetCode 练习题

**数组**

- Three Sum（求三数之和）

英文版： <https://leetcode.com/problems/3sum/>

中文版： <https://leetcode-cn.com/problems/3sum/>

- Majority Element（求众数）

英文版： <https://leetcode.com/problems/majority-element/>

中文版： <https://leetcode-cn.com/problems/majority-element/>

- Missing Positive（求缺失的第一个正数）

英文版： <https://leetcode.com/problems/first-missing-positive/>

中文版： <https://leetcode-cn.com/problems/first-missing-positive/>

**链表**

- Linked List Cycle I（环形链表）

英文版： <https://leetcode.com/problems/linked-list-cycle/>

中文版： <https://leetcode-cn.com/problems/linked-list-cycle/>

- Merge k Sorted Lists（合并 k 个排序链表）

英文版： <https://leetcode.com/problems/merge-k-sorted-lists/>

中文版： <https://leetcode-cn.com/problems/merge-k-sorted-lists/>

## Day 2：栈、队列和递归

> 关于栈、队列和递归的几个必知必会的代码实现

### 栈

- 用数组实现一个顺序栈
- 用链表实现一个链式栈
- 编程模拟实现一个浏览器的前进、后退功能

### 队列

- 用数组实现一个顺序队列
- 用链表实现一个链式队列
- 实现一个循环队列

### 递归

- 编程实现斐波那契数列求值 $f(n)=f(n-1)+f(n-2)$
- 编程实现求阶乘 n!
- 编程实现一组数据集合的全排列

### 对应的 LeetCode 练习题

**栈**

- Valid Parentheses（有效的括号）

英文版： <https://leetcode.com/problems/valid-parentheses/>

中文版： <https://leetcode-cn.com/problems/valid-parentheses/>

- Longest Valid Parentheses（最长有效的括号）

英文版： <https://leetcode.com/problems/longest-valid-parentheses/>

中文版： <https://leetcode-cn.com/problems/longest-valid-parentheses/>

- Evaluate Reverse Polish Notatio（逆波兰表达式求值）

英文版： <https://leetcode.com/problems/evaluate-reverse-polish-notation/>

中文版： <https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/>

**队列**

- Design Circular Deque（设计一个双端队列）

英文版： <https://leetcode.com/problems/design-circular-deque/>

中文版： <https://leetcode-cn.com/problems/design-circular-deque/>

- Sliding Window Maximum（滑动窗口最大值）

英文版： <https://leetcode.com/problems/sliding-window-maximum/>

中文版： <https://leetcode-cn.com/problems/sliding-window-maximum/>

**递归**

- Climbing Stairs（爬楼梯）

英文版： <https://leetcode.com/problems/climbing-stairs/>

中文版： <https://leetcode-cn.com/problems/climbing-stairs/>

## Day 3：排序和二分查找

> 关于排序和二分查找的几个必知必会的代码实现

### 排序

- 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
- 编程实现 $O(logn)$ 时间复杂度内找到一组数据的第 K 大元素

### 二分查找

- 实现一个有序数组的二分查找算法
- 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

### 对应的 LeetCode 练习题

- Sqrt(x) （x 的平方根）

英文版： <https://leetcode.com/problems/sqrtx/>

中文版： <https://leetcode-cn.com/problems/sqrtx/>

## Day 4：散列表和字符串

> 关于散列表和字符串的 4 个必知必会的代码实现

### 散列表

- 实现一个基于链表法解决冲突问题的散列表
- 实现一个 LRU 缓存淘汰算法

### 字符串

- 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树
- 实现朴素的字符串匹配算法

### 对应的 LeetCode 练习题

**字符串**

- Reverse String （反转字符串）

英文版： <https://leetcode.com/problems/reverse-string/>

中文版： <https://leetcode-cn.com/problems/reverse-string/>

- Reverse Words in a String（翻转字符串里的单词）

英文版： <https://leetcode.com/problems/reverse-words-in-a-string/>

中文版： <https://leetcode-cn.com/problems/reverse-words-in-a-string/>

- String to Integer (atoi)（字符串转换整数 (atoi)）

英文版： <https://leetcode.com/problems/string-to-integer-atoi/>

中文版： <https://leetcode-cn.com/problems/string-to-integer-atoi/>

## Day 5：二叉树和堆

> 关于二叉树和堆的 7 个必知必会的代码实现

### 二叉树

- 实现一个二叉查找树，并且支持插入、删除、查找操作
- 实现查找二叉查找树中某个节点的后继、前驱节点
- 实现二叉树前、中、后序以及按层遍历

### 堆

- 实现一个小顶堆、大顶堆、优先级队列
- 实现堆排序
- 利用优先级队列合并 K 个有序数组
- 求一组动态数据集合的最大 Top K

### 对应的 LeetCode 练习题

- Invert Binary Tree（翻转二叉树）

英文版： <https://leetcode.com/problems/invert-binary-tree/>

中文版： <https://leetcode-cn.com/problems/invert-binary-tree/>

- Maximum Depth of Binary Tree（二叉树的最大深度）

英文版： <https://leetcode.com/problems/maximum-depth-of-binary-tree/>

中文版： <https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/>

- Validate Binary Search Tree（验证二叉查找树）

英文版： <https://leetcode.com/problems/validate-binary-search-tree/>

中文版： <https://leetcode-cn.com/problems/validate-binary-search-tree/>

- Path Sum（路径总和）

英文版： <https://leetcode.com/problems/path-sum/>

中文版： <https://leetcode-cn.com/problems/path-sum/>

## Day 6：图

> 关于图的几个必知必会的代码实现

### 图

- 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法
- 实现图的深度优先搜索、广度优先搜索
- 实现 Dijkstra 算法、A* 算法
- 实现拓扑排序的 Kahn 算法、DFS 算法

### 对应的 LeetCode 练习题

- Number of Islands（岛屿的个数）

英文版： <https://leetcode.com/problems/number-of-islands/description/>

中文版： <https://leetcode-cn.com/problems/number-of-islands/description/>

- Valid Sudoku（有效的数独）

英文版： <https://leetcode.com/problems/valid-sudoku/>

中文版： <https://leetcode-cn.com/problems/valid-sudoku/>

## Day 7：贪心、分治、回溯和动态规划

> 几种算法思想必知必会的代码实现

### 回溯

- 利用回溯算法求解八皇后问题
- 利用回溯算法求解 0-1 背包问题

### 分治

- 利用分治算法求一组数据的逆序对个数

### 动态规划

- 0-1 背包问题
- 最小路径和
- 编程实现莱文斯坦最短编辑距离
- 编程实现查找两个字符串的最长公共子序列
- 编程实现一个数据序列的最长递增子序列

### 对应的 LeetCode 练习题

- Regular Expression Matching（正则表达式匹配）

英文版： <https://leetcode.com/problems/regular-expression-matching/>

中文版： <https://leetcode-cn.com/problems/regular-expression-matching/>

- Minimum Path Sum（最小路径和）

英文版： <https://leetcode.com/problems/minimum-path-sum/>

中文版： <https://leetcode-cn.com/problems/minimum-path-sum/>

- Coin Change （零钱兑换）

英文版： <https://leetcode.com/problems/coin-change/>

中文版： <https://leetcode-cn.com/problems/coin-change/>

- Best Time to Buy and Sell Stock（买卖股票的最佳时机）

英文版： <https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>

中文版： <https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/>

- Maximum Product Subarray（乘积最大子序列）

英文版： <https://leetcode.com/problems/maximum-product-subarray/>

中文版： <https://leetcode-cn.com/problems/maximum-product-subarray/>

- Triangle（三角形最小路径和）

英文版： <https://leetcode.com/problems/triangle/>

中文版： <https://leetcode-cn.com/problems/triangle/>
